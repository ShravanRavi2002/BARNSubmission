# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from graph_navigation/socialNavSrvRequest.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import amrl_msgs.msg
import geometry_msgs.msg
import nav_msgs.msg
import sensor_msgs.msg
import std_msgs.msg

class socialNavSrvRequest(genpy.Message):
  _md5sum = "13277f5033f27d56fe4431aa1fedc627"
  _type = "graph_navigation/socialNavSrvRequest"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """int32 action
amrl_msgs/Pose2Df goal_pose
geometry_msgs/Pose2D loc
nav_msgs/Odometry odom
sensor_msgs/LaserScan laser
float64 time
geometry_msgs/Pose2D[] human_poses
geometry_msgs/Pose2D[] human_vels

================================================================================
MSG: amrl_msgs/Pose2Df
float32 x
float32 y
float32 theta
================================================================================
MSG: geometry_msgs/Pose2D
# Deprecated
# Please use the full 3D pose.

# In general our recommendation is to use a full 3D representation of everything and for 2D specific applications make the appropriate projections into the plane for their calculations but optimally will preserve the 3D information during processing.

# If we have parallel copies of 2D datatypes every UI and other pipeline will end up needing to have dual interfaces to plot everything. And you will end up with not being able to use 3D tools for 2D use cases even if they're completely valid, as you'd have to reimplement it with different inputs and outputs. It's not particularly hard to plot the 2D pose or compute the yaw error for the Pose message and there are already tools and libraries that can do this for you.


# This expresses a position and orientation on a 2D manifold.

float64 x
float64 y
float64 theta

================================================================================
MSG: nav_msgs/Odometry
# This represents an estimate of a position and velocity in free space.  
# The pose in this message should be specified in the coordinate frame given by header.frame_id.
# The twist in this message should be specified in the coordinate frame given by the child_frame_id
Header header
string child_frame_id
geometry_msgs/PoseWithCovariance pose
geometry_msgs/TwistWithCovariance twist

================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
string frame_id

================================================================================
MSG: geometry_msgs/PoseWithCovariance
# This represents a pose in free space with uncertainty.

Pose pose

# Row-major representation of the 6x6 covariance matrix
# The orientation parameters use a fixed-axis representation.
# In order, the parameters are:
# (x, y, z, rotation about X axis, rotation about Y axis, rotation about Z axis)
float64[36] covariance

================================================================================
MSG: geometry_msgs/Pose
# A representation of pose in free space, composed of position and orientation. 
Point position
Quaternion orientation

================================================================================
MSG: geometry_msgs/Point
# This contains the position of a point in free space
float64 x
float64 y
float64 z

================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w

================================================================================
MSG: geometry_msgs/TwistWithCovariance
# This expresses velocity in free space with uncertainty.

Twist twist

# Row-major representation of the 6x6 covariance matrix
# The orientation parameters use a fixed-axis representation.
# In order, the parameters are:
# (x, y, z, rotation about X axis, rotation about Y axis, rotation about Z axis)
float64[36] covariance

================================================================================
MSG: geometry_msgs/Twist
# This expresses velocity in free space broken into its linear and angular parts.
Vector3  linear
Vector3  angular

================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z
================================================================================
MSG: sensor_msgs/LaserScan
# Single scan from a planar laser range-finder
#
# If you have another ranging device with different behavior (e.g. a sonar
# array), please find or create a different message, since applications
# will make fairly laser-specific assumptions about this data

Header header            # timestamp in the header is the acquisition time of 
                         # the first ray in the scan.
                         #
                         # in frame frame_id, angles are measured around 
                         # the positive Z axis (counterclockwise, if Z is up)
                         # with zero angle being forward along the x axis
                         
float32 angle_min        # start angle of the scan [rad]
float32 angle_max        # end angle of the scan [rad]
float32 angle_increment  # angular distance between measurements [rad]

float32 time_increment   # time between measurements [seconds] - if your scanner
                         # is moving, this will be used in interpolating position
                         # of 3d points
float32 scan_time        # time between scans [seconds]

float32 range_min        # minimum range value [m]
float32 range_max        # maximum range value [m]

float32[] ranges         # range data [m] (Note: values < range_min or > range_max should be discarded)
float32[] intensities    # intensity data [device-specific units].  If your
                         # device does not provide intensities, please leave
                         # the array empty.
"""
  __slots__ = ['action','goal_pose','loc','odom','laser','time','human_poses','human_vels']
  _slot_types = ['int32','amrl_msgs/Pose2Df','geometry_msgs/Pose2D','nav_msgs/Odometry','sensor_msgs/LaserScan','float64','geometry_msgs/Pose2D[]','geometry_msgs/Pose2D[]']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       action,goal_pose,loc,odom,laser,time,human_poses,human_vels

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(socialNavSrvRequest, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.action is None:
        self.action = 0
      if self.goal_pose is None:
        self.goal_pose = amrl_msgs.msg.Pose2Df()
      if self.loc is None:
        self.loc = geometry_msgs.msg.Pose2D()
      if self.odom is None:
        self.odom = nav_msgs.msg.Odometry()
      if self.laser is None:
        self.laser = sensor_msgs.msg.LaserScan()
      if self.time is None:
        self.time = 0.
      if self.human_poses is None:
        self.human_poses = []
      if self.human_vels is None:
        self.human_vels = []
    else:
      self.action = 0
      self.goal_pose = amrl_msgs.msg.Pose2Df()
      self.loc = geometry_msgs.msg.Pose2D()
      self.odom = nav_msgs.msg.Odometry()
      self.laser = sensor_msgs.msg.LaserScan()
      self.time = 0.
      self.human_poses = []
      self.human_vels = []

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_i3f3d3I().pack(_x.action, _x.goal_pose.x, _x.goal_pose.y, _x.goal_pose.theta, _x.loc.x, _x.loc.y, _x.loc.theta, _x.odom.header.seq, _x.odom.header.stamp.secs, _x.odom.header.stamp.nsecs))
      _x = self.odom.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.odom.child_frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_7d().pack(_x.odom.pose.pose.position.x, _x.odom.pose.pose.position.y, _x.odom.pose.pose.position.z, _x.odom.pose.pose.orientation.x, _x.odom.pose.pose.orientation.y, _x.odom.pose.pose.orientation.z, _x.odom.pose.pose.orientation.w))
      buff.write(_get_struct_36d().pack(*self.odom.pose.covariance))
      _x = self
      buff.write(_get_struct_6d().pack(_x.odom.twist.twist.linear.x, _x.odom.twist.twist.linear.y, _x.odom.twist.twist.linear.z, _x.odom.twist.twist.angular.x, _x.odom.twist.twist.angular.y, _x.odom.twist.twist.angular.z))
      buff.write(_get_struct_36d().pack(*self.odom.twist.covariance))
      _x = self
      buff.write(_get_struct_3I().pack(_x.laser.header.seq, _x.laser.header.stamp.secs, _x.laser.header.stamp.nsecs))
      _x = self.laser.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_7f().pack(_x.laser.angle_min, _x.laser.angle_max, _x.laser.angle_increment, _x.laser.time_increment, _x.laser.scan_time, _x.laser.range_min, _x.laser.range_max))
      length = len(self.laser.ranges)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(struct.Struct(pattern).pack(*self.laser.ranges))
      length = len(self.laser.intensities)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(struct.Struct(pattern).pack(*self.laser.intensities))
      _x = self.time
      buff.write(_get_struct_d().pack(_x))
      length = len(self.human_poses)
      buff.write(_struct_I.pack(length))
      for val1 in self.human_poses:
        _x = val1
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.theta))
      length = len(self.human_vels)
      buff.write(_struct_I.pack(length))
      for val1 in self.human_vels:
        _x = val1
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.theta))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.goal_pose is None:
        self.goal_pose = amrl_msgs.msg.Pose2Df()
      if self.loc is None:
        self.loc = geometry_msgs.msg.Pose2D()
      if self.odom is None:
        self.odom = nav_msgs.msg.Odometry()
      if self.laser is None:
        self.laser = sensor_msgs.msg.LaserScan()
      if self.human_poses is None:
        self.human_poses = None
      if self.human_vels is None:
        self.human_vels = None
      end = 0
      _x = self
      start = end
      end += 52
      (_x.action, _x.goal_pose.x, _x.goal_pose.y, _x.goal_pose.theta, _x.loc.x, _x.loc.y, _x.loc.theta, _x.odom.header.seq, _x.odom.header.stamp.secs, _x.odom.header.stamp.nsecs,) = _get_struct_i3f3d3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.odom.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.odom.header.frame_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.odom.child_frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.odom.child_frame_id = str[start:end]
      _x = self
      start = end
      end += 56
      (_x.odom.pose.pose.position.x, _x.odom.pose.pose.position.y, _x.odom.pose.pose.position.z, _x.odom.pose.pose.orientation.x, _x.odom.pose.pose.orientation.y, _x.odom.pose.pose.orientation.z, _x.odom.pose.pose.orientation.w,) = _get_struct_7d().unpack(str[start:end])
      start = end
      end += 288
      self.odom.pose.covariance = _get_struct_36d().unpack(str[start:end])
      _x = self
      start = end
      end += 48
      (_x.odom.twist.twist.linear.x, _x.odom.twist.twist.linear.y, _x.odom.twist.twist.linear.z, _x.odom.twist.twist.angular.x, _x.odom.twist.twist.angular.y, _x.odom.twist.twist.angular.z,) = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 288
      self.odom.twist.covariance = _get_struct_36d().unpack(str[start:end])
      _x = self
      start = end
      end += 12
      (_x.laser.header.seq, _x.laser.header.stamp.secs, _x.laser.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.laser.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.laser.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 28
      (_x.laser.angle_min, _x.laser.angle_max, _x.laser.angle_increment, _x.laser.time_increment, _x.laser.scan_time, _x.laser.range_min, _x.laser.range_max,) = _get_struct_7f().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.laser.ranges = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.laser.intensities = s.unpack(str[start:end])
      start = end
      end += 8
      (self.time,) = _get_struct_d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.human_poses = []
      for i in range(0, length):
        val1 = geometry_msgs.msg.Pose2D()
        _x = val1
        start = end
        end += 24
        (_x.x, _x.y, _x.theta,) = _get_struct_3d().unpack(str[start:end])
        self.human_poses.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.human_vels = []
      for i in range(0, length):
        val1 = geometry_msgs.msg.Pose2D()
        _x = val1
        start = end
        end += 24
        (_x.x, _x.y, _x.theta,) = _get_struct_3d().unpack(str[start:end])
        self.human_vels.append(val1)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_i3f3d3I().pack(_x.action, _x.goal_pose.x, _x.goal_pose.y, _x.goal_pose.theta, _x.loc.x, _x.loc.y, _x.loc.theta, _x.odom.header.seq, _x.odom.header.stamp.secs, _x.odom.header.stamp.nsecs))
      _x = self.odom.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.odom.child_frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_7d().pack(_x.odom.pose.pose.position.x, _x.odom.pose.pose.position.y, _x.odom.pose.pose.position.z, _x.odom.pose.pose.orientation.x, _x.odom.pose.pose.orientation.y, _x.odom.pose.pose.orientation.z, _x.odom.pose.pose.orientation.w))
      buff.write(self.odom.pose.covariance.tostring())
      _x = self
      buff.write(_get_struct_6d().pack(_x.odom.twist.twist.linear.x, _x.odom.twist.twist.linear.y, _x.odom.twist.twist.linear.z, _x.odom.twist.twist.angular.x, _x.odom.twist.twist.angular.y, _x.odom.twist.twist.angular.z))
      buff.write(self.odom.twist.covariance.tostring())
      _x = self
      buff.write(_get_struct_3I().pack(_x.laser.header.seq, _x.laser.header.stamp.secs, _x.laser.header.stamp.nsecs))
      _x = self.laser.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_7f().pack(_x.laser.angle_min, _x.laser.angle_max, _x.laser.angle_increment, _x.laser.time_increment, _x.laser.scan_time, _x.laser.range_min, _x.laser.range_max))
      length = len(self.laser.ranges)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(self.laser.ranges.tostring())
      length = len(self.laser.intensities)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(self.laser.intensities.tostring())
      _x = self.time
      buff.write(_get_struct_d().pack(_x))
      length = len(self.human_poses)
      buff.write(_struct_I.pack(length))
      for val1 in self.human_poses:
        _x = val1
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.theta))
      length = len(self.human_vels)
      buff.write(_struct_I.pack(length))
      for val1 in self.human_vels:
        _x = val1
        buff.write(_get_struct_3d().pack(_x.x, _x.y, _x.theta))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.goal_pose is None:
        self.goal_pose = amrl_msgs.msg.Pose2Df()
      if self.loc is None:
        self.loc = geometry_msgs.msg.Pose2D()
      if self.odom is None:
        self.odom = nav_msgs.msg.Odometry()
      if self.laser is None:
        self.laser = sensor_msgs.msg.LaserScan()
      if self.human_poses is None:
        self.human_poses = None
      if self.human_vels is None:
        self.human_vels = None
      end = 0
      _x = self
      start = end
      end += 52
      (_x.action, _x.goal_pose.x, _x.goal_pose.y, _x.goal_pose.theta, _x.loc.x, _x.loc.y, _x.loc.theta, _x.odom.header.seq, _x.odom.header.stamp.secs, _x.odom.header.stamp.nsecs,) = _get_struct_i3f3d3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.odom.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.odom.header.frame_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.odom.child_frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.odom.child_frame_id = str[start:end]
      _x = self
      start = end
      end += 56
      (_x.odom.pose.pose.position.x, _x.odom.pose.pose.position.y, _x.odom.pose.pose.position.z, _x.odom.pose.pose.orientation.x, _x.odom.pose.pose.orientation.y, _x.odom.pose.pose.orientation.z, _x.odom.pose.pose.orientation.w,) = _get_struct_7d().unpack(str[start:end])
      start = end
      end += 288
      self.odom.pose.covariance = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=36)
      _x = self
      start = end
      end += 48
      (_x.odom.twist.twist.linear.x, _x.odom.twist.twist.linear.y, _x.odom.twist.twist.linear.z, _x.odom.twist.twist.angular.x, _x.odom.twist.twist.angular.y, _x.odom.twist.twist.angular.z,) = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 288
      self.odom.twist.covariance = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=36)
      _x = self
      start = end
      end += 12
      (_x.laser.header.seq, _x.laser.header.stamp.secs, _x.laser.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.laser.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.laser.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 28
      (_x.laser.angle_min, _x.laser.angle_max, _x.laser.angle_increment, _x.laser.time_increment, _x.laser.scan_time, _x.laser.range_min, _x.laser.range_max,) = _get_struct_7f().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.laser.ranges = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.laser.intensities = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
      start = end
      end += 8
      (self.time,) = _get_struct_d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.human_poses = []
      for i in range(0, length):
        val1 = geometry_msgs.msg.Pose2D()
        _x = val1
        start = end
        end += 24
        (_x.x, _x.y, _x.theta,) = _get_struct_3d().unpack(str[start:end])
        self.human_poses.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.human_vels = []
      for i in range(0, length):
        val1 = geometry_msgs.msg.Pose2D()
        _x = val1
        start = end
        end += 24
        (_x.x, _x.y, _x.theta,) = _get_struct_3d().unpack(str[start:end])
        self.human_vels.append(val1)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_36d = None
def _get_struct_36d():
    global _struct_36d
    if _struct_36d is None:
        _struct_36d = struct.Struct("<36d")
    return _struct_36d
_struct_3I = None
def _get_struct_3I():
    global _struct_3I
    if _struct_3I is None:
        _struct_3I = struct.Struct("<3I")
    return _struct_3I
_struct_3d = None
def _get_struct_3d():
    global _struct_3d
    if _struct_3d is None:
        _struct_3d = struct.Struct("<3d")
    return _struct_3d
_struct_6d = None
def _get_struct_6d():
    global _struct_6d
    if _struct_6d is None:
        _struct_6d = struct.Struct("<6d")
    return _struct_6d
_struct_7d = None
def _get_struct_7d():
    global _struct_7d
    if _struct_7d is None:
        _struct_7d = struct.Struct("<7d")
    return _struct_7d
_struct_7f = None
def _get_struct_7f():
    global _struct_7f
    if _struct_7f is None:
        _struct_7f = struct.Struct("<7f")
    return _struct_7f
_struct_d = None
def _get_struct_d():
    global _struct_d
    if _struct_d is None:
        _struct_d = struct.Struct("<d")
    return _struct_d
_struct_i3f3d3I = None
def _get_struct_i3f3d3I():
    global _struct_i3f3d3I
    if _struct_i3f3d3I is None:
        _struct_i3f3d3I = struct.Struct("<i3f3d3I")
    return _struct_i3f3d3I
# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from graph_navigation/socialNavSrvResponse.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import geometry_msgs.msg

class socialNavSrvResponse(genpy.Message):
  _md5sum = "cad38f811f0bb09a90ee26031f3342ab"
  _type = "graph_navigation/socialNavSrvResponse"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """float32 cmd_vel
float32 cmd_curve
geometry_msgs/Pose2D local_target
int32 target_id


================================================================================
MSG: geometry_msgs/Pose2D
# Deprecated
# Please use the full 3D pose.

# In general our recommendation is to use a full 3D representation of everything and for 2D specific applications make the appropriate projections into the plane for their calculations but optimally will preserve the 3D information during processing.

# If we have parallel copies of 2D datatypes every UI and other pipeline will end up needing to have dual interfaces to plot everything. And you will end up with not being able to use 3D tools for 2D use cases even if they're completely valid, as you'd have to reimplement it with different inputs and outputs. It's not particularly hard to plot the 2D pose or compute the yaw error for the Pose message and there are already tools and libraries that can do this for you.


# This expresses a position and orientation on a 2D manifold.

float64 x
float64 y
float64 theta
"""
  __slots__ = ['cmd_vel','cmd_curve','local_target','target_id']
  _slot_types = ['float32','float32','geometry_msgs/Pose2D','int32']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       cmd_vel,cmd_curve,local_target,target_id

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(socialNavSrvResponse, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.cmd_vel is None:
        self.cmd_vel = 0.
      if self.cmd_curve is None:
        self.cmd_curve = 0.
      if self.local_target is None:
        self.local_target = geometry_msgs.msg.Pose2D()
      if self.target_id is None:
        self.target_id = 0
    else:
      self.cmd_vel = 0.
      self.cmd_curve = 0.
      self.local_target = geometry_msgs.msg.Pose2D()
      self.target_id = 0

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_2f3di().pack(_x.cmd_vel, _x.cmd_curve, _x.local_target.x, _x.local_target.y, _x.local_target.theta, _x.target_id))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.local_target is None:
        self.local_target = geometry_msgs.msg.Pose2D()
      end = 0
      _x = self
      start = end
      end += 36
      (_x.cmd_vel, _x.cmd_curve, _x.local_target.x, _x.local_target.y, _x.local_target.theta, _x.target_id,) = _get_struct_2f3di().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_2f3di().pack(_x.cmd_vel, _x.cmd_curve, _x.local_target.x, _x.local_target.y, _x.local_target.theta, _x.target_id))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.local_target is None:
        self.local_target = geometry_msgs.msg.Pose2D()
      end = 0
      _x = self
      start = end
      end += 36
      (_x.cmd_vel, _x.cmd_curve, _x.local_target.x, _x.local_target.y, _x.local_target.theta, _x.target_id,) = _get_struct_2f3di().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_2f3di = None
def _get_struct_2f3di():
    global _struct_2f3di
    if _struct_2f3di is None:
        _struct_2f3di = struct.Struct("<2f3di")
    return _struct_2f3di
class socialNavSrv(object):
  _type          = 'graph_navigation/socialNavSrv'
  _md5sum = 'f7baac1423368c10d81e6b27873e08cf'
  _request_class  = socialNavSrvRequest
  _response_class = socialNavSrvResponse
