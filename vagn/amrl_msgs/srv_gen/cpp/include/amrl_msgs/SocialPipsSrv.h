/* Auto-generated by genmsg_cpp for file /home/amrl-user/nav_challange/vagn/amrl_msgs/srv/SocialPipsSrv.srv */
#ifndef AMRL_MSGS_SERVICE_SOCIALPIPSSRV_H
#define AMRL_MSGS_SERVICE_SOCIALPIPSSRV_H
#include <string>
#include <vector>
#include <map>
#include <ostream>
#include "ros/serialization.h"
#include "ros/builtin_message_traits.h"
#include "ros/message_operations.h"
#include "ros/time.h"

#include "ros/macros.h"

#include "ros/assert.h"

#include "ros/service_traits.h"

#include "amrl_msgs/Pose2Df.h"
#include "amrl_msgs/Pose2Df.h"
#include "amrl_msgs/Pose2Df.h"
#include "amrl_msgs/Pose2Df.h"
#include "amrl_msgs/Pose2Df.h"
#include "amrl_msgs/Pose2Df.h"
#include "amrl_msgs/Pose2Df.h"



namespace amrl_msgs
{
template <class ContainerAllocator>
struct SocialPipsSrvRequest_ {
  typedef SocialPipsSrvRequest_<ContainerAllocator> Type;

  SocialPipsSrvRequest_()
  : robot_poses()
  , robot_vels()
  , human_poses()
  , human_vels()
  , goal_pose()
  , local_target()
  , door_pose()
  , door_state(0)
  , robot_state(0)
  , follow_target(0)
  {
  }

  SocialPipsSrvRequest_(const ContainerAllocator& _alloc)
  : robot_poses(_alloc)
  , robot_vels(_alloc)
  , human_poses(_alloc)
  , human_vels(_alloc)
  , goal_pose(_alloc)
  , local_target(_alloc)
  , door_pose(_alloc)
  , door_state(0)
  , robot_state(0)
  , follow_target(0)
  {
  }

  typedef std::vector< ::amrl_msgs::Pose2Df_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::amrl_msgs::Pose2Df_<ContainerAllocator> >::other >  _robot_poses_type;
  std::vector< ::amrl_msgs::Pose2Df_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::amrl_msgs::Pose2Df_<ContainerAllocator> >::other >  robot_poses;

  typedef std::vector< ::amrl_msgs::Pose2Df_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::amrl_msgs::Pose2Df_<ContainerAllocator> >::other >  _robot_vels_type;
  std::vector< ::amrl_msgs::Pose2Df_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::amrl_msgs::Pose2Df_<ContainerAllocator> >::other >  robot_vels;

  typedef std::vector< ::amrl_msgs::Pose2Df_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::amrl_msgs::Pose2Df_<ContainerAllocator> >::other >  _human_poses_type;
  std::vector< ::amrl_msgs::Pose2Df_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::amrl_msgs::Pose2Df_<ContainerAllocator> >::other >  human_poses;

  typedef std::vector< ::amrl_msgs::Pose2Df_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::amrl_msgs::Pose2Df_<ContainerAllocator> >::other >  _human_vels_type;
  std::vector< ::amrl_msgs::Pose2Df_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::amrl_msgs::Pose2Df_<ContainerAllocator> >::other >  human_vels;

  typedef  ::amrl_msgs::Pose2Df_<ContainerAllocator>  _goal_pose_type;
   ::amrl_msgs::Pose2Df_<ContainerAllocator>  goal_pose;

  typedef  ::amrl_msgs::Pose2Df_<ContainerAllocator>  _local_target_type;
   ::amrl_msgs::Pose2Df_<ContainerAllocator>  local_target;

  typedef  ::amrl_msgs::Pose2Df_<ContainerAllocator>  _door_pose_type;
   ::amrl_msgs::Pose2Df_<ContainerAllocator>  door_pose;

  typedef uint8_t _door_state_type;
  uint8_t door_state;

  typedef uint8_t _robot_state_type;
  uint8_t robot_state;

  typedef int32_t _follow_target_type;
  int32_t follow_target;


  typedef boost::shared_ptr< ::amrl_msgs::SocialPipsSrvRequest_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::amrl_msgs::SocialPipsSrvRequest_<ContainerAllocator>  const> ConstPtr;
}; // struct SocialPipsSrvRequest
typedef  ::amrl_msgs::SocialPipsSrvRequest_<std::allocator<void> > SocialPipsSrvRequest;

typedef boost::shared_ptr< ::amrl_msgs::SocialPipsSrvRequest> SocialPipsSrvRequestPtr;
typedef boost::shared_ptr< ::amrl_msgs::SocialPipsSrvRequest const> SocialPipsSrvRequestConstPtr;



template <class ContainerAllocator>
struct SocialPipsSrvResponse_ {
  typedef SocialPipsSrvResponse_<ContainerAllocator> Type;

  SocialPipsSrvResponse_()
  : action(0)
  {
  }

  SocialPipsSrvResponse_(const ContainerAllocator& _alloc)
  : action(0)
  {
  }

  typedef int32_t _action_type;
  int32_t action;


  typedef boost::shared_ptr< ::amrl_msgs::SocialPipsSrvResponse_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::amrl_msgs::SocialPipsSrvResponse_<ContainerAllocator>  const> ConstPtr;
}; // struct SocialPipsSrvResponse
typedef  ::amrl_msgs::SocialPipsSrvResponse_<std::allocator<void> > SocialPipsSrvResponse;

typedef boost::shared_ptr< ::amrl_msgs::SocialPipsSrvResponse> SocialPipsSrvResponsePtr;
typedef boost::shared_ptr< ::amrl_msgs::SocialPipsSrvResponse const> SocialPipsSrvResponseConstPtr;


struct SocialPipsSrv
{

typedef SocialPipsSrvRequest Request;
typedef SocialPipsSrvResponse Response;
Request request;
Response response;

typedef Request RequestType;
typedef Response ResponseType;
}; // struct SocialPipsSrv
} // namespace amrl_msgs

namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::amrl_msgs::SocialPipsSrvRequest_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::amrl_msgs::SocialPipsSrvRequest_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::amrl_msgs::SocialPipsSrvRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "052818ab8e58241ff3fff1fb3eabf54a";
  }

  static const char* value(const  ::amrl_msgs::SocialPipsSrvRequest_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0x052818ab8e58241fULL;
  static const uint64_t static_value2 = 0xf3fff1fb3eabf54aULL;
};

template<class ContainerAllocator>
struct DataType< ::amrl_msgs::SocialPipsSrvRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "amrl_msgs/SocialPipsSrvRequest";
  }

  static const char* value(const  ::amrl_msgs::SocialPipsSrvRequest_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::amrl_msgs::SocialPipsSrvRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "Pose2Df[] robot_poses\n\
Pose2Df[] robot_vels\n\
Pose2Df[] human_poses\n\
Pose2Df[] human_vels\n\
Pose2Df goal_pose\n\
Pose2Df local_target\n\
Pose2Df door_pose\n\
uint8 door_state\n\
\n\
\n\
\n\
\n\
uint8 robot_state\n\
\n\
int32 follow_target\n\
\n\
================================================================================\n\
MSG: amrl_msgs/Pose2Df\n\
float32 x\n\
float32 y\n\
float32 theta\n\
";
  }

  static const char* value(const  ::amrl_msgs::SocialPipsSrvRequest_<ContainerAllocator> &) { return value(); } 
};

} // namespace message_traits
} // namespace ros


namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::amrl_msgs::SocialPipsSrvResponse_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::amrl_msgs::SocialPipsSrvResponse_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::amrl_msgs::SocialPipsSrvResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "b028501ac85c840a01d50342b4cc9b6e";
  }

  static const char* value(const  ::amrl_msgs::SocialPipsSrvResponse_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0xb028501ac85c840aULL;
  static const uint64_t static_value2 = 0x01d50342b4cc9b6eULL;
};

template<class ContainerAllocator>
struct DataType< ::amrl_msgs::SocialPipsSrvResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "amrl_msgs/SocialPipsSrvResponse";
  }

  static const char* value(const  ::amrl_msgs::SocialPipsSrvResponse_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::amrl_msgs::SocialPipsSrvResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "int32 action\n\
\n\
\n\
";
  }

  static const char* value(const  ::amrl_msgs::SocialPipsSrvResponse_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator> struct IsFixedSize< ::amrl_msgs::SocialPipsSrvResponse_<ContainerAllocator> > : public TrueType {};
} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::amrl_msgs::SocialPipsSrvRequest_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.robot_poses);
    stream.next(m.robot_vels);
    stream.next(m.human_poses);
    stream.next(m.human_vels);
    stream.next(m.goal_pose);
    stream.next(m.local_target);
    stream.next(m.door_pose);
    stream.next(m.door_state);
    stream.next(m.robot_state);
    stream.next(m.follow_target);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER
}; // struct SocialPipsSrvRequest_
} // namespace serialization
} // namespace ros


namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::amrl_msgs::SocialPipsSrvResponse_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.action);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER
}; // struct SocialPipsSrvResponse_
} // namespace serialization
} // namespace ros

namespace ros
{
namespace service_traits
{
template<>
struct MD5Sum<amrl_msgs::SocialPipsSrv> {
  static const char* value() 
  {
    return "5aa4c05a0d89a6541e472d48f0f846f8";
  }

  static const char* value(const amrl_msgs::SocialPipsSrv&) { return value(); } 
};

template<>
struct DataType<amrl_msgs::SocialPipsSrv> {
  static const char* value() 
  {
    return "amrl_msgs/SocialPipsSrv";
  }

  static const char* value(const amrl_msgs::SocialPipsSrv&) { return value(); } 
};

template<class ContainerAllocator>
struct MD5Sum<amrl_msgs::SocialPipsSrvRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "5aa4c05a0d89a6541e472d48f0f846f8";
  }

  static const char* value(const amrl_msgs::SocialPipsSrvRequest_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct DataType<amrl_msgs::SocialPipsSrvRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "amrl_msgs/SocialPipsSrv";
  }

  static const char* value(const amrl_msgs::SocialPipsSrvRequest_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct MD5Sum<amrl_msgs::SocialPipsSrvResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "5aa4c05a0d89a6541e472d48f0f846f8";
  }

  static const char* value(const amrl_msgs::SocialPipsSrvResponse_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct DataType<amrl_msgs::SocialPipsSrvResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "amrl_msgs/SocialPipsSrv";
  }

  static const char* value(const amrl_msgs::SocialPipsSrvResponse_<ContainerAllocator> &) { return value(); } 
};

} // namespace service_traits
} // namespace ros

#endif // AMRL_MSGS_SERVICE_SOCIALPIPSSRV_H

